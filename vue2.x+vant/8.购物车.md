### 购物车

#### 购物车产品文档

1. 用户可以在商品四级页（商品详情页）通过点击 __*加入购物车* __按钮,弹出当前商品的可选参数或套餐
2. 用户选择完毕后，点击确认按钮，进行加车操作
3. 加车操作支持登录和未登录两种加车行为；
4. 用户可以通过首页页脚tabbar点击*购物车*按钮进入到购物车页面
5. 如果当前购物车没有内容，则提示用户当前购物车为空的操作
6. 如果当前购物车内有商品数据，则展示购物车列表相关数据
7. 购物车页面中展示猜你喜欢模块

#### 加车功能的概要设计

1. 在商品详情页面，点击*加入购物车*按钮,给此按钮添加selectSpecifications点击事件,来换起选择规则弹层；

   ```javascript
   export default {
   	data(){
           return {
               popupStatus : false, //默认弹层为不展示
           }
       },
       methods:{
           //弹出选择商品规格的弹层
           selectSpecifications(){
               this.popupStatus = true;
           }
       }
   }
   ```

 2. 用户手动选择完商品规格后，点击确认按钮，进行加车操作

    ```javascript
    export default {
    	data(){
            return {
                productInfo:[]
            }
        },
        async created(){
            //获取商品详情信息接口
            let productInfo = await this.getProductInfo({
                productId:10001
            });
            this.productInfo = productInfo.data;
        },
        methods:{
            //加入购物车
            async increaseCart(){
                // 如果用户未选择套餐，则提示用户去选择套餐；
                if(this.meal === null){
                    alert('请选择套餐')
                    return;
                }
                //在加车的入参时，要和服务端沟通好，一次性将所有的商品信息全部传给服务端
                //可以在将来服务端在该接口中需要加参数时，前端完全不用修改任何代码，增加了代码的可维护性
                //如果用户登录时，可以调用服务端的接口；
                //服务端通过你传的token值，加上你传的参数，
                //服务端就可以判断是谁加了购物车里面的什么东西；
                //但是，如果当前用户未登录，
                //这个购物车，我该加给谁？ 
                //这个服务端是找不到谁的购物车中有什么东西的；
                //此时的解决方案是：localStorage
                let res = await this.addCard({
                    productInfo: this.productInfo，
                    count:5,  //数据
                    meal: 10  //套餐
                });
            }
        }
    }
    ```

#### 购物车页面概要设计

1. 如果用户已登录，则调用服务端的接口，来获取到购物车列表相关数据，前端负责展示，

   ```javascript
   export default{
       data(){
           return {
               cartList:[]  //购物车列表
           }
       },
       async created(){
           //购物车列表，是以店为维度来加车的
           //购物车列表，是以店为维度来加车的
           //购物车列表，是以店为维度来加车的
           let cartList = await this.getCartList();
           
           let cartList = {
               status:1,
               msg:'success',
               data:[
                   {
                       shopId:100001,
                       shopName:'康乐福官方自营店',
                       data:[
                           {
                               productId:10012,
                               productName:'汤蔬倍健',
                               price:100
                           },
                           {
                               productId:10012,
                               productName:'汤蔬倍健',
                               price:100
                           },
                       ]
                   },
                   {
                       shopId:100002,
                       shopName:'康乐福官方自营店2',
                       data:[
                           {
                               productId:10012,
                               productName:'汤蔬倍健',
                               price:100
                           },
                           {
                               productId:10012,
                               productName:'汤蔬倍健',
                               price:100
                           },
                       ]
                   },
               ]
           }
           this.cartList = cartList.data;
       }
   }
   ```

2. 未登录时的加车逻辑

   ```javascript
   export default{
       data(){
           return {
               cartList:[]
           }
       },
       created(){
           //如果用户未登录，我们需要去localStorage中去拿到对应的购物车商品
   		this.cartList = localStorage.getItem('cartlist');
       }
   }
   ```

   

3. 并车功能

   1. 在打开页面时，先从localStorage中取出购物车列表数据；（这些数据是未登录时的购物车商品数据）
   2. 如果当前用户已登录
   3. 则把localStorage中的商品添加到用户的购物车中；
   4. 通过getCartList()接口，获取购物车列表，
   5. 统一渲染到页面上；

   ```javascript
   export default{
       data(){
           return {
               cartList:[]
           }
       },
       created(){
           //首先先查看本地存储中是否有购物车相关数据；
           let localStorageCartList = localStorage.getItem('cartlist') || '';
           if(token){
               await this.addCart({
                   localStorageCartList
               })
               this.cartList = await this.getCartList();
           }
           this.cartList = localStorageCartList;
       }
   }
   ```

   

4. 同时调用猜你喜欢的接口，来拿到服务端的数据；

   ```javascript
   export default {
       data(){
           return {
               likelist:[],  //猜你喜欢的列表
           }
       },
       async created(){
           let likelist = await this.getLikeList();
           this.likelist = likelist.data;
       }
   }
   ```









#### computed 和 watch的区别？

https://www.cnblogs.com/jiajialove/p/11327945.html

```javascript
1. computed 是计算属性， 他的适用场景是： 当一个或多个值发生变化时，另外一值也必须随之变化时，就应该用computed的计算属性
2. watch是兼听当前的数据有没有变化，如果有变化叫自己的业务逻辑操作，他没有返回值；
3. computed不支持异步，watch支持异步

//  当 sex = 1 男    sex = 0 时 女
export default {
    data(){
        sex:1,
    },
    computed:{
        sexName(){
            return this.sex == 1 ? '男' : '女'
        }
    }
}
```

