### day10

1.  说一说你对jwt的理解？
   1.   jwt全称叫jsonwebtoken，是一种跨域登录的方案；

2.  你们的登录是如何做的？
   1. 我们的项目是前后端分离的一个项目，登录这块，我们采用的是市场上主流的解决方案jwt;

3.  什么是前后端分离？ 前后端分离的好处？
   1. 前后端分离是把项目分解成两个组，一个前端，一个后端
   2. 前端负责页面及交互相关逻辑
   3. 服务端负责数据处理相关逻辑
   4. 好处： 分工更明确，因为随着前端工程化体系的出现，如果全部交给后端，学习成本会更高
   5. 好处二： 开发效率可以更快，因为可以同步开发 ，服务端写接口的同时，前端就可以写页面相关逻辑，前端也可以直接模拟服务端的假数据，还有一些公司用到了mock.js 这个js是用来模拟服务端的假数据的；

4.  说一说你对前端的工程化的理解？
   1. 就是目前我们所说的项目模块化，一般指的是用webpack ,或者 Vue-cli 或者说是 cra来创建的项目；

5.  你在项目中用到过mockjs吗？
   1. mock.js  的作用是 模拟服务端接口的假数据, 
   2. 在项目中，我们没有用到，但是了解过，因为我们的项目中，服务端在写接口文档的时候，会给你模拟好；

6.  服务端给你们写的接口文档的类型是什么类型？
   1. excel 类型，  或者 world文档类型

7.  前后端如何连调？ 如何判断前端问题，还是后端问题？
   1. 一般情况下，开发完以后前后端会进行代码连调，如果遇到问题，一般会通过浏览器中的f12，查看当前接口传到接口的入参是否正确，如果 正确，就把对应的报文（接口名，入参，出参，调用接口的时间）发给服务端同学，之后服务端同学就会配合查找问题

8.  前端校验 和后端 校验的区别吗？
   1. 答： 前端校验是为了减小服务端的压力； 
   2. 服务端校验是为了安全
   3. 在校验form表单，通常前端后端会同时校验，绝对不会出现 只有前端，或者只有后端校验的情况；

9.  axios的相关配置

    1.  api.js的同一级，手动创建一个 config.js 该配置文件中，配置了 post请求和 get请求，或者一些用来上传，下载时用的配置文件；

10.  如果是单页面应用，在设置history 模式中，发布服务器的时候会报错，只能找 index.vue 其它的路由都会失效，你有遇到过这个问题吗？

     1.  解决方案：在服务器中配置nginx，设置如下内容

     2.  ```awk
         location /{
         
                 root   /data/nginx/html;
                 index  index.html index.htm;
         
                 if (!-e $request_filename) {
                     rewrite ^/(.*) /index.html last;
                     break;
                 }
         }
         ```

11.  说一下对事件监听，事件委托，事件冒泡，事件捕获的理解 及其应用场景？

    事件监听 addEventListener 

    事件委托（基于事件监听，给想添加点击事件的元素的父级设置addEventlistener）  

    事件冒泡（从里到外），     阻止冒泡： ev.**stopPropagation**()    ie浏览器: e.cancelBabel = true

    事件捕获（从外到里)   几乎在项目中不，不会用到 捕获事件流

12.  addEventListener 和click的区别？

    1. 两个api都是给dom设置事件；
    2. 一个dom只能设置一个click事件，如果设置多个，最后设置的click事件，会覆盖之前的；
    3. addEventListener 可以同时设置多个；

13.  事件委托的理解 ？及使用场景？ 

    1. $('.parent').on('click','.children-el',function(){  console.log( '这叫事件委托' )})
    2. 如果你不会答这道题，说明你做过的所有jquery项目，都是假的，
    3. 他在项目中，不可能不用；

14. jquery常用语法

    ```javascript
    // jquery 常用，必备语法
    //  eq: 找到第几个  
    // find  找到 item中的第1个下面的一个子元素，子元素类名叫.item
    // parent，找的是当前元素的父级
    //  parents， 找到的是当前元素中所有的父级；
    //  html()  给当前元素设置html内容  相当于 原生js的   dom.innerHTML = '';
    // css({width:100px,height:50px;display:flex})  //给当前dom设置样式
    // show()  展示当前元素
    // hide()  隐藏当前元素；
    // 加上事件监听
    ```

15. 